# -*- coding: utf-8 -*-
"""
plugins/indicators.py  [MUTABLE]
================================
기술적 지표 플러그인: SuperTrend, JMA, RSI.
"""
from __future__ import annotations
from typing import Dict, Any
import numpy as np
import pandas as pd
from core.interfaces import IIndicator


class SuperTrendIndicator(IIndicator):
    def name(self) -> str:
        return "SuperTrend"

    def compute(self, df: pd.DataFrame, params: Dict[str, Any]) -> pd.DataFrame:
        period = params.get("st_period", 14)
        multiplier = params.get("st_multiplier", 3.0)

        high = df["high"].values
        low = df["low"].values
        close = df["close"].values
        n = len(close)

        # ATR
        tr = np.zeros(n)
        for i in range(1, n):
            tr[i] = max(high[i] - low[i],
                        abs(high[i] - close[i - 1]),
                        abs(low[i] - close[i - 1]))
        tr[0] = high[0] - low[0]

        atr = np.zeros(n)
        atr[:period] = np.mean(tr[:period]) if period <= n else np.mean(tr)
        for i in range(period, n):
            atr[i] = (atr[i - 1] * (period - 1) + tr[i]) / period

        # SuperTrend
        upper = np.zeros(n)
        lower = np.zeros(n)
        st = np.zeros(n)
        direction = np.ones(n)  # 1 = up (bull), -1 = down (bear)

        hl2 = (high + low) / 2
        upper = hl2 + multiplier * atr
        lower = hl2 - multiplier * atr

        final_upper = upper.copy()
        final_lower = lower.copy()

        for i in range(1, n):
            if lower[i] > final_lower[i - 1] or close[i - 1] < final_lower[i - 1]:
                final_lower[i] = lower[i]
            else:
                final_lower[i] = final_lower[i - 1]

            if upper[i] < final_upper[i - 1] or close[i - 1] > final_upper[i - 1]:
                final_upper[i] = upper[i]
            else:
                final_upper[i] = final_upper[i - 1]

            if direction[i - 1] == 1:  # was bull
                if close[i] < final_lower[i]:
                    direction[i] = -1
                    st[i] = final_upper[i]
                else:
                    direction[i] = 1
                    st[i] = final_lower[i]
            else:  # was bear
                if close[i] > final_upper[i]:
                    direction[i] = 1
                    st[i] = final_lower[i]
                else:
                    direction[i] = -1
                    st[i] = final_upper[i]

        st[0] = final_upper[0] if close[0] < final_upper[0] else final_lower[0]

        df = df.copy()
        df["st"] = st
        df["st_dir"] = direction
        df["atr"] = atr
        return df


class JMAIndicator(IIndicator):
    """Jurik Moving Average — pandas_ta 참조 구현 포팅."""
    def name(self) -> str:
        return "JMA"

    def compute(self, df: pd.DataFrame, params: Dict[str, Any]) -> pd.DataFrame:
        length = params.get("jma_length", 7)
        phase = params.get("jma_phase", 50)
        close = df["close"].values.astype(float)
        n = len(close)

        if n < 2:
            df = df.copy()
            df["jma"] = close
            df["jma_slope"] = 0.0
            return df

        # phase → beta 변환
        if phase < -100:
            phase = -100
        elif phase > 100:
            phase = 100

        if phase >= 0:
            phaseRatio = phase / 100.0
        else:
            phaseRatio = phase / 50.0  # [-100,0) → [-2,0)

        beta = 0.45 * (length - 1) / (0.45 * (length - 1) + 2)
        power = 2.0 if phaseRatio >= 0 else max(0.5, phaseRatio + 2)
        alpha = beta ** power

        jma = np.full(n, np.nan)
        e0 = np.zeros(n)
        e1 = np.zeros(n)
        e2 = np.zeros(n)

        e0[0] = close[0]
        e1[0] = 0.0
        e2[0] = close[0]
        jma[0] = close[0]

        for i in range(1, n):
            e0[i] = (1 - alpha) * close[i] + alpha * e0[i - 1]
            e1[i] = (close[i] - e0[i]) * (1 - beta) + beta * e1[i - 1]
            e2[i] = e0[i] + phaseRatio * e1[i]

            # Adaptive smoothing (simplified JMA)
            jma[i] = e2[i]

        df = df.copy()
        df["jma"] = jma

        # JMA 기울기 (1일 차분)
        slope = np.zeros(n)
        for i in range(1, n):
            if not np.isnan(jma[i]) and not np.isnan(jma[i - 1]):
                slope[i] = jma[i] - jma[i - 1]
        df["jma_slope"] = slope

        return df


class RSIIndicator(IIndicator):
    """RSI — 필터용."""
    def name(self) -> str:
        return "RSI"

    def compute(self, df: pd.DataFrame, params: Dict[str, Any]) -> pd.DataFrame:
        period = params.get("rsi_period", 14)
        close = df["close"].values.astype(float)
        n = len(close)

        rsi = np.full(n, 50.0)
        if n < period + 1:
            df = df.copy()
            df["rsi"] = rsi
            return df

        delta = np.diff(close, prepend=close[0])
        gain = np.where(delta > 0, delta, 0.0)
        loss = np.where(delta < 0, -delta, 0.0)

        avg_gain = np.mean(gain[1:period + 1])
        avg_loss = np.mean(loss[1:period + 1])

        for i in range(period + 1, n):
            avg_gain = (avg_gain * (period - 1) + gain[i]) / period
            avg_loss = (avg_loss * (period - 1) + loss[i]) / period
            if avg_loss == 0:
                rsi[i] = 100.0
            else:
                rs = avg_gain / avg_loss
                rsi[i] = 100 - 100 / (1 + rs)

        # 초기값 채우기
        if avg_loss == 0:
            rsi[period] = 100.0
        else:
            rsi[period] = 100 - 100 / (1 + avg_gain / max(avg_loss, 1e-10))

        df = df.copy()
        df["rsi"] = rsi
        return df
