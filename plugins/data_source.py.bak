# -*- coding: utf-8 -*-
"""
plugins/data_source.py  [MUTABLE]
=================================
데이터 소스 어댑터.

우선순위:
  1) MySQL (daily_candles) — 5년 일봉, 가장 빠름
  2) CybosServer (localhost:8081) — 실시간/분봉/틱/보조
  3) KiwoomServer (localhost:8082) — Cybos 경유 캔들 + 주문 전용

core_engine, pykrx, FinanceDataReader 등 외부 의존 없음.
"""
from __future__ import annotations
from typing import Any, Optional, Dict, List
import pandas as pd
import numpy as np
import requests
import logging
import traceback
from datetime import datetime
from pathlib import Path

from core.interfaces import IDataSource

logger = logging.getLogger(__name__)
_LOG_DIR = Path("data/logs")
_LOG_DIR.mkdir(parents=True, exist_ok=True)

_REQUEST_TIMEOUT = 15  # 초


def _log_error(msg: str) -> None:
    try:
        with open(_LOG_DIR / "error_log.txt", "a", encoding="utf-8") as f:
            f.write(f"[{datetime.now():%Y-%m-%d %H:%M:%S}] {msg}\n")
    except Exception:
        pass


# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#  1) MySQL 데이터 소스 — 일봉 주력
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
class MySQLDataSource(IDataSource):
    """
    MySQL stock_info.daily_candles 에서 일봉 조회.
    5년치 2,100만 건 저장되어 있으므로 가장 빠르고 안정적.

    Parameters
    ----------
    host, port, user, password, database : MySQL 접속 정보
    """

    def __init__(
        self,
        host: str = "localhost",
        port: int = 3306,
        user: str = "root",
        password: str = "",
        database: str = "stock_info",
    ) -> None:
        self._conn_params = {
            "host": host,
            "port": port,
            "user": user,
            "password": password,
            "database": database,
        }
        self._engine = None
        self._init_engine()

    def _init_engine(self) -> None:
        """SQLAlchemy 엔진 생성 (pymysql 사용)."""
        try:
            from sqlalchemy import create_engine
            p = self._conn_params
            url = (
                f"mysql+pymysql://{p['user']}:{p['password']}"
                f"@{p['host']}:{p['port']}/{p['database']}"
                f"?charset=utf8mb4"
            )
            self._engine = create_engine(url, pool_pre_ping=True, pool_size=3)
            
			# 연결 테스트
            from sqlalchemy import text
            with self._engine.connect() as conn:
                conn.execute(text("SELECT 1"))

            logger.info(f"MySQL connected: {p['host']}:{p['port']}/{p['database']}")
        except Exception as e:
            logger.warning(f"MySQL connection failed: {e}")
            self._engine = None

    def fetch_candles(self, code: str, start: str, end: str) -> pd.DataFrame:
        """
        daily_candles 테이블에서 종목 일봉 조회.

        Parameters
        ----------
        code : 종목코드 6자리 (예: '005930')
        start : 시작일 'YYYY-MM-DD' 또는 'YYYYMMDD'
        end : 종료일 'YYYY-MM-DD' 또는 'YYYYMMDD'
        """
        if not self._engine:
            return pd.DataFrame()

        try:
            # 코드 정리: 'A005930' → '005930'
            code = code.replace("A", "").strip()

            # 날짜 정리
            start_dt = self._parse_date(start)
            end_dt = self._parse_date(end)

            query = """
                SELECT date, open, high, low, close, volume, tramount, change_pct
                FROM daily_candles
                WHERE code = %(code)s
                  AND date BETWEEN %(start)s AND %(end)s
                ORDER BY date ASC
            """
            df = pd.read_sql(query, self._engine,
                             params={"code": code, "start": start_dt, "end": end_dt})

            if df.empty:
                logger.warning(f"MySQL: {code} 데이터 없음 ({start_dt} ~ {end_dt})")
                return pd.DataFrame()

            df["date"] = pd.to_datetime(df["date"])
            df["open"] = df["open"].astype(float)
            df["high"] = df["high"].astype(float)
            df["low"] = df["low"].astype(float)
            df["close"] = df["close"].astype(float)
            df["volume"] = df["volume"].astype(int)

            logger.info(f"MySQL: {code} loaded {len(df)} rows ({start_dt} ~ {end_dt})")
            return df

        except Exception as e:
            msg = f"MySQL fetch_candles({code}) error: {e}\n{traceback.format_exc()}"
            logger.error(msg)
            _log_error(msg)
            return pd.DataFrame()

    def fetch_index_candles(self, index_code: str, start: str, end: str) -> pd.DataFrame:
        """
        KOSPI 지수 일봉 — MySQL에 지수 테이블이 없으면 CybosServer로 폴백.
        index_code: 'KOSPI' → Cybos code 'U001'
                    'KOSDAQ' → Cybos code 'U201'
        """
        # MySQL에 지수 테이블이 있으면 여기서 처리
        # 없으면 CybosServer로 위임
        cybos = CybosDataSource()
        return cybos.fetch_index_candles(index_code, start, end)

    def _parse_date(self, date_str: str) -> str:
        """다양한 날짜 형식을 'YYYY-MM-DD'로 변환."""
        if not date_str:
            return "2020-01-01"
        date_str = date_str.strip().replace("/", "-")
        if len(date_str) == 8 and "-" not in date_str:
            # YYYYMMDD → YYYY-MM-DD
            return f"{date_str[:4]}-{date_str[4:6]}-{date_str[6:8]}"
        return date_str


# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#  2) CybosServer 데이터 소스 — 실시간/분봉/틱/지수
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
class CybosDataSource(IDataSource):
    """
    CybosPlus Data Server (localhost:8081) HTTP API.

    일봉: /api/candles?code=A005930&timeframe=D&count=200
    기간: /api/candles_period?code=A005930&timeframe=D&fromdate=20250801&todate=20260207
    지수: /api/candles?code=U001&timeframe=D&count=200  (KOSPI)
    """

    def __init__(self, base_url: str = "http://localhost:8081") -> None:
        self.base_url = base_url.rstrip("/")

    def _is_alive(self) -> bool:
        """서버 상태 체크."""
        try:
            r = requests.get(f"{self.base_url}/api/status", timeout=3)
            return r.status_code == 200
        except Exception:
            return False

    def fetch_candles(self, code: str, start: str, end: str) -> pd.DataFrame:
        """
        종목 일봉 조회.
        start/end가 있으면 candles_period, 없으면 candles + count.
        """
        try:
            # 코드 보정: '005930' → 'A005930'
            api_code = self._to_cybos_code(code)

            if start and end:
                # 기간 조회
                from_date = start.replace("-", "")
                to_date = end.replace("-", "")
                url = (
                    f"{self.base_url}/api/candles_period"
                    f"?code={api_code}&timeframe=D"
                    f"&fromdate={from_date}&todate={to_date}"
                )
            else:
                # 최근 N개
                url = f"{self.base_url}/api/candles?code={api_code}&timeframe=D&count=200"

            r = requests.get(url, timeout=_REQUEST_TIMEOUT)
            r.raise_for_status()
            body = r.json()

            if not body.get("Success"):
                logger.warning(f"Cybos: {code} failed: {body.get('Message', '')}")
                return pd.DataFrame()

            return self._parse_candle_response(body.get("Data", []))

        except Exception as e:
            msg = f"Cybos fetch_candles({code}) error: {e}\n{traceback.format_exc()}"
            logger.error(msg)
            _log_error(msg)
            return pd.DataFrame()

    def fetch_index_candles(self, index_code: str, start: str, end: str) -> pd.DataFrame:
        """
        지수 일봉 조회.
        KOSPI → U001, KOSDAQ → U201
        """
        try:
            cybos_code = self._index_to_cybos(index_code)

            if start and end:
                from_date = start.replace("-", "")
                to_date = end.replace("-", "")
                url = (
                    f"{self.base_url}/api/candles_period"
                    f"?code={cybos_code}&timeframe=D"
                    f"&fromdate={from_date}&todate={to_date}"
                )
            else:
                url = f"{self.base_url}/api/candles?code={cybos_code}&timeframe=D&count=200"

            r = requests.get(url, timeout=_REQUEST_TIMEOUT)
            r.raise_for_status()
            body = r.json()

            if not body.get("Success"):
                logger.warning(f"Cybos index: {index_code} failed: {body.get('Message', '')}")
                return pd.DataFrame()

            df = self._parse_candle_response(body.get("Data", []))
            logger.info(f"Cybos index: {index_code} loaded {len(df)} rows")
            return df

        except Exception as e:
            msg = f"Cybos fetch_index({index_code}) error: {e}\n{traceback.format_exc()}"
            logger.error(msg)
            _log_error(msg)
            return pd.DataFrame()

    def fetch_candles_minutes(self, code: str, timeframe: str = "m1",
                              start: str = "", end: str = "") -> pd.DataFrame:
        """
        분봉 조회 (실시간 전략용).
        timeframe: m1, m3, m5, m10, m15, m30, m60, m240
        """
        try:
            api_code = self._to_cybos_code(code)
            if start and end:
                url = (
                    f"{self.base_url}/api/candles_period"
                    f"?code={api_code}&timeframe={timeframe}"
                    f"&fromdate={start.replace('-','')}&todate={end.replace('-','')}"
                )
            else:
                url = f"{self.base_url}/api/candles?code={api_code}&timeframe={timeframe}&count=500"

            r = requests.get(url, timeout=_REQUEST_TIMEOUT)
            r.raise_for_status()
            body = r.json()

            if not body.get("Success"):
                return pd.DataFrame()

            return self._parse_candle_response(body.get("Data", []))

        except Exception as e:
            logger.error(f"Cybos minutes({code}, {timeframe}) error: {e}")
            return pd.DataFrame()

    def fetch_investor_trend(self, code: str, start: str, end: str) -> pd.DataFrame:
        """투자자별 매매 동향 조회."""
        try:
            api_code = self._to_cybos_code(code)
            url = (
                f"{self.base_url}/api/investor-trend"
                f"?code={api_code}"
                f"&from={start.replace('-','')}&to={end.replace('-','')}"
            )
            r = requests.get(url, timeout=_REQUEST_TIMEOUT)
            r.raise_for_status()
            body = r.json()

            if not body.get("Success"):
                return pd.DataFrame()

            data = body.get("Data", [])
            if data:
                return pd.DataFrame(data)
            return pd.DataFrame()

        except Exception as e:
            logger.error(f"Cybos investor_trend({code}) error: {e}")
            return pd.DataFrame()

    def _to_cybos_code(self, code: str) -> str:
        """종목코드 → Cybos 형식 (A 접두사)."""
        code = code.strip()
        if code.startswith("U") or code.startswith("A"):
            return code
        return f"A{code}"

    def _index_to_cybos(self, index_code: str) -> str:
        """지수명 → Cybos 코드."""
        mapping = {
            "KOSPI": "U001",
            "001": "U001",
            "KOSDAQ": "U201",
            "201": "U201",
        }
        return mapping.get(index_code.upper(), f"U{index_code}")

    def _parse_candle_response(self, data: list) -> pd.DataFrame:
        """Cybos API 응답 → 표준 DataFrame."""
        if not data:
            return pd.DataFrame()

        df = pd.DataFrame(data)
        # 컬럼 매핑: Cybos 응답은 Timestamp, Open, High, Low, Close, Volume
        col_map = {}
        for col in df.columns:
            cl = col.lower().strip()
            if cl in ("timestamp", "date", "날짜", "일자", "time"):
                col_map[col] = "date"
            elif cl == "open":
                col_map[col] = "open"
            elif cl == "high":
                col_map[col] = "high"
            elif cl == "low":
                col_map[col] = "low"
            elif cl == "close":
                col_map[col] = "close"
            elif cl == "volume":
                col_map[col] = "volume"

        df = df.rename(columns=col_map)

        if "date" in df.columns:
            df["date"] = pd.to_datetime(df["date"], errors="coerce")

        for col in ["open", "high", "low", "close"]:
            if col in df.columns:
                df[col] = pd.to_numeric(df[col], errors="coerce")

        if "volume" in df.columns:
            df["volume"] = pd.to_numeric(df["volume"], errors="coerce").fillna(0).astype(int)

        # NaN 제거
        df = df.dropna(subset=["open", "high", "low", "close"])

        # 날짜 오름차순 정렬
        if "date" in df.columns:
            df = df.sort_values("date").reset_index(drop=True)

        return df


# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#  3) Kiwoom 데이터 소스 — 주문/잔고 + 캔들(Cybos 경유)
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
class KiwoomDataSource(IDataSource):
    """
    KiwoomServer (localhost:8082) — 주로 주문/잔고용.
    캔들 데이터는 내부적으로 Cybos를 경유하므로 CybosDataSource와 동일 형식.
    """

    def __init__(self, base_url: str = "http://localhost:8082") -> None:
        self.base_url = base_url.rstrip("/")

    def fetch_candles(self, code: str, start: str, end: str) -> pd.DataFrame:
        """Kiwoom 경유 캔들 조회 (Cybos 캐시)."""
        try:
            api_code = code.replace("A", "").strip()
            if start and end:
                url = (
                    f"{self.base_url}/api/candles_period"
                    f"?code={api_code}&timeframe=D"
                    f"&fromdate={start.replace('-','')}&enddate={end.replace('-','')}"
                )
            else:
                url = f"{self.base_url}/api/candles?code=A{api_code}&timeframe=D&count=200"

            r = requests.get(url, timeout=_REQUEST_TIMEOUT)
            r.raise_for_status()
            body = r.json()

            if not body.get("Success"):
                return pd.DataFrame()

            # Cybos와 동일한 파서 사용
            return CybosDataSource()._parse_candle_response(body.get("Data", []))

        except Exception as e:
            logger.error(f"Kiwoom fetch_candles({code}) error: {e}")
            return pd.DataFrame()

    def fetch_index_candles(self, index_code: str, start: str, end: str) -> pd.DataFrame:
        """지수는 CybosServer로 직접 조회."""
        return CybosDataSource().fetch_index_candles(index_code, start, end)


# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#  4) 복합 데이터 소스 — 자동 폴백
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
class CompositeDataSource(IDataSource):
    """
    MySQL → CybosServer → KiwoomServer 순으로 폴백.
    하나라도 성공하면 해당 데이터 반환.

    이것이 main.py에서 사용할 기본 데이터 소스입니다.
    """

    def __init__(
        self,
        mysql_params: Optional[Dict[str, Any]] = None,
        cybos_url: str = "http://localhost:8081",
        kiwoom_url: str = "http://localhost:8082",
    ) -> None:
        self._sources: List[IDataSource] = []
        self._source_names: List[str] = []

        # 1) MySQL (가장 빠름)
        if mysql_params:
            try:
                src = MySQLDataSource(**mysql_params)
                if src._engine is not None:
                    self._sources.append(src)
                    self._source_names.append("MySQL")
            except Exception as e:
                logger.warning(f"MySQL init failed: {e}")

        # 2) CybosServer
        try:
            cybos = CybosDataSource(cybos_url)
            if cybos._is_alive():
                self._sources.append(cybos)
                self._source_names.append("Cybos")
            else:
                logger.warning("CybosServer not responding")
        except Exception:
            pass

        # 3) KiwoomServer (폴백)
        try:
            kiwoom = KiwoomDataSource(kiwoom_url)
            self._sources.append(kiwoom)
            self._source_names.append("Kiwoom")
        except Exception:
            pass

        logger.info(f"CompositeDataSource: active sources = {self._source_names}")

    def fetch_candles(self, code: str, start: str, end: str) -> pd.DataFrame:
        """순서대로 시도, 첫 성공 결과 반환."""
        for i, src in enumerate(self._sources):
            try:
                df = src.fetch_candles(code, start, end)
                if df is not None and not df.empty:
                    logger.debug(f"{code}: data from {self._source_names[i]} ({len(df)} rows)")
                    return df
            except Exception as e:
                logger.debug(f"{code}: {self._source_names[i]} failed: {e}")
                continue

        logger.warning(f"{code}: all data sources failed")
        return pd.DataFrame()

    def fetch_index_candles(self, index_code: str, start: str, end: str) -> pd.DataFrame:
        """지수는 Cybos 우선, MySQL에 지수 테이블이 있으면 MySQL 우선."""
        for i, src in enumerate(self._sources):
            try:
                df = src.fetch_index_candles(index_code, start, end)
                if df is not None and not df.empty:
                    logger.debug(f"Index {index_code}: from {self._source_names[i]}")
                    return df
            except Exception as e:
                logger.debug(f"Index {index_code}: {self._source_names[i]} failed: {e}")
                continue

        logger.warning(f"Index {index_code}: all sources failed")
        return pd.DataFrame()
