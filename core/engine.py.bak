# -*- coding: utf-8 -*-
"""
core/engine.py  [IMMUTABLE]
===========================
백테스트 + 실매매 공통 루프.
플러그인(IDataSource, IIndicator, ISignalGenerator 등)을 받아 실행.
"""
from __future__ import annotations
from typing import List, Dict, Any, Optional
import logging
import traceback
from datetime import datetime
from pathlib import Path
import pandas as pd
import numpy as np

from core.types import Signal, Direction, TradeRecord, BacktestResult, Regime
from core.interfaces import (
    IDataSource, IIndicator, ISignalGenerator, IRegimeDetector, IRiskGate,
)
from core.risk import RiskManager
from core.metrics import calc_metrics
from core.event_bus import EventBus

logger = logging.getLogger(__name__)
_LOG_DIR = Path("data/logs")
_LOG_DIR.mkdir(parents=True, exist_ok=True)


def _log_error(msg: str) -> None:
    try:
        with open(_LOG_DIR / "error_log.txt", "a", encoding="utf-8") as f:
            f.write(f"[{datetime.now():%Y-%m-%d %H:%M:%S}] {msg}\n")
    except Exception:
        pass


class BacktestEngine:
    """
    백테스트 엔진.
    조립(Composition Root)에서 플러그인을 주입받는다.
    """

    def __init__(
        self,
        data_source: IDataSource,
        indicators: List[IIndicator],
        signal_gen: ISignalGenerator,
        regime_detector: Optional[IRegimeDetector] = None,
        risk_gate: Optional[IRiskGate] = None,
        event_bus: Optional[EventBus] = None,
        params: Optional[Dict[str, Any]] = None,
    ) -> None:
        self.data_source = data_source
        self.indicators = indicators
        self.signal_gen = signal_gen
        self.regime_detector = regime_detector
        self.risk_gate = risk_gate
        self.bus = event_bus or EventBus()
        self.params = params or {}

    def run(self, code: str, start: str, end: str,
            initial_capital: float = 10_000_000) -> Optional[BacktestResult]:
        """단일 종목 백테스트 실행. 종목마다 독립된 리스크 상태 사용."""
        try:
            # ── 데이터 로드 ──
            df = self.data_source.fetch_candles(code, start, end)
            if df is None or df.empty:
                logger.warning(f"{code}: 데이터 없음")
                return None

            # 데이터 검증
            df = self._validate_data(df)
            if df.empty:
                return None

            # ── 레짐 판단 (선택) ──
            regime = Regime.BULL
            if self.regime_detector:
                try:
                    idx_df = self.data_source.fetch_index_candles("KOSPI", start, end)
                    if idx_df is not None and not idx_df.empty:
                        regime = self.regime_detector.detect(idx_df, self.params)
                except Exception:
                    pass

            # ── 지표 계산 ──
            for ind in self.indicators:
                try:
                    df = ind.compute(df, self.params)
                except Exception as e:
                    logger.error(f"{code}: indicator {ind.name()} failed: {e}")

            # ── 신호 생성 ──
            signals = self.signal_gen.generate(df, code, self.params)

            # ── 시뮬레이션 (종목별 독립 리스크) ──
            result = self._simulate(df, signals, code, initial_capital, regime)
            self.bus.publish("backtest_done", code=code, result=result)
            return result

        except Exception as e:
            msg = f"BacktestEngine.run({code}) error: {e}\n{traceback.format_exc()}"
            logger.error(msg)
            _log_error(msg)
            return None

    def run_batch(self, codes: List[str], start: str, end: str,
                  initial_capital: float = 10_000_000) -> List[BacktestResult]:
        """여러 종목 일괄 백테스트. 종목마다 완전 독립."""
        results = []
        for code in codes:
            result = self.run(code, start, end, initial_capital)
            if result:
                results.append(result)
        return results

    def _validate_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """NaN/Inf 제거, 필수 컬럼 확인."""
        required = ["open", "high", "low", "close", "volume"]
        for col in required:
            if col not in df.columns:
                logger.error(f"Missing column: {col}")
                return pd.DataFrame()

        df = df.replace([np.inf, -np.inf], np.nan)
        df = df.dropna(subset=["open", "high", "low", "close"])
        return df

    def _simulate(
        self,
        df: pd.DataFrame,
        signals: List[Signal],
        code: str,
        capital: float,
        regime: Regime,
    ) -> BacktestResult:
        """
        단순 시뮬레이션: 신호 기반 매수/매도.
        ★ 리스크 체크는 종목별로 새로운 RiskManager 인스턴스를 사용.
        """
        trades: List[TradeRecord] = []
        equity = []
        position = None  # 현재 포지션 (TradeRecord)
        current_capital = capital
        shares = 0

        # ★ 종목별 독립 리스크 매니저 생성
        local_risk = self._create_local_risk()

        # 신호를 날짜 기준으로 매핑
        signal_map: Dict = {}
        for sig in signals:
            signal_map[sig.dt] = sig

        for idx, row in df.iterrows():
            dt = row.get("date", idx)
            close = row["close"]

            sig = signal_map.get(dt)

            if sig and sig.direction == Direction.BUY and position is None:
                # 리스크 체크 (종목별 독립)
                if local_risk:
                    if not local_risk.check({"code": code, "side": "BUY",
                                              "price": close, "capital": current_capital}):
                        equity.append(current_capital)
                        continue

                shares = int(current_capital * 0.95 / close) if close > 0 else 0
                if shares > 0:
                    position = TradeRecord(
                        code=code,
                        entry_date=dt,
                        entry_price=close,
                        shares=shares,
                    )
                    current_capital -= shares * close
                    if local_risk:
                        local_risk.on_position_opened()

            elif sig and sig.direction == Direction.SELL and position is not None:
                position.exit_date = dt
                position.exit_price = close
                pnl = (close - position.entry_price) * position.shares
                position.pnl = pnl
                position.pnl_pct = ((close / position.entry_price) - 1) * 100 if position.entry_price > 0 else 0
                position.exit_reason = sig.reason
                current_capital += position.shares * close
                trades.append(position)
                if local_risk:
                    local_risk.on_trade_closed(position)
                position = None
                shares = 0

            # 자산 평가
            if position is not None:
                equity.append(current_capital + position.shares * close)
            else:
                equity.append(current_capital)

        # 미청산 포지션 강제 청산
        if position is not None and len(df) > 0:
            last_row = df.iloc[-1]
            last_close = last_row["close"]
            last_dt = last_row.get("date", df.index[-1])
            position.exit_date = last_dt
            position.exit_price = last_close
            pnl = (last_close - position.entry_price) * position.shares
            position.pnl = pnl
            position.pnl_pct = ((last_close / position.entry_price) - 1) * 100 if position.entry_price > 0 else 0
            position.exit_reason = "period_end"
            current_capital += position.shares * last_close
            trades.append(position)

        eq_series = pd.Series(equity, name="equity") if equity else pd.Series(dtype=float)
        return calc_metrics(code, trades, capital, eq_series)

    def _create_local_risk(self) -> Optional[RiskManager]:
        """
        종목별 독립 RiskManager 생성.
        글로벌 risk_gate의 파라미터를 복사하되, 상태는 초기화.
        """
        if self.risk_gate and isinstance(self.risk_gate, RiskManager):
            return RiskManager(
                max_daily_loss_pct=self.risk_gate.max_daily_loss_pct,
                max_monthly_loss_pct=self.risk_gate.max_monthly_loss_pct,
                max_consecutive_losses=self.risk_gate.max_consecutive_losses,
                max_positions=self.risk_gate.max_positions,
                max_per_stock_pct=self.risk_gate.max_per_stock_pct,
            )
        return None
